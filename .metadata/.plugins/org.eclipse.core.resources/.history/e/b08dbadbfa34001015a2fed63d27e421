/**
 ********************************************************************************
 * @file diskio_spi.c
 * @author
 * @brief
 ********************************************************************************
 */

/************************************
 * INCLUDES
 ************************************/
#include "diskio_spi.h"
#include "spi.h"

/************************************
 * EXTERN VARIABLES
 ************************************/
//SDHC card

/************************************
 * PRIVATE MACROS AND DEFINES
 ************************************/
/* SPI Commands */
#define CMD0
#define CMD_START_BIT
#define CMD_FORMAT()

// SPI Specific Macros
#define ASSERT_SDCARD_CS() HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_RESET)
#define DEASSERT_SDCARD_CS() HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_SET)

// Clear BaudRate register (bits [5:3] of CR1)then write 256 as the slow prescaler (~200khz) and 4 as the fast (~12mhz)
#define SLOW_SPI_CLK() MODIFY_REG(hspi2.instance->CR1, SPI_CR1_BR, SPI_BAUDRATEPRESCALER_256)
#define FAST_SPI_CLK() MODIFY_REG(hspi2.instance->CR1, SPI_CR1_BR, SPI_BAUDRATEPRESCALER_4)

// SD Card Config. Macros
#define sdCardPresent() TRUE
#define sdCardWriteProtected() TRUE

/************************************
 * PRIVATE TYPEDEFS
 ************************************/

/************************************
 * STATIC VARIABLES
 ************************************/
// Timing Functionality
static UINT uiStartTime;
static UINT uiDelayTime;

// Card Status (By default: no init, not present, write protected)
static DSTATUS ucCardStatus = STA_NOINIT |  STA_NODISK |STA_PROTECT;

/************************************
 * GLOBAL VARIABLES
 ************************************/

/************************************
 * STATIC FUNCTION PROTOTYPES
 ************************************/
// Timer functionality
static void startTimer(UINT uiTime_);
static UINT timerDone();

// SPI Functionality
static UCHAR spiSendReceiveByte (UCHAR data_);
static void spiReceiveBytes (UCHAR* receive_, UINT length_);
static void spiSendBytes (const UCHAR* const data_, UINT length_);
static inline BOOLE spiSelect();
static inline BOOLE spiDeselect();

// Command TX/RX
static BOOLE sdCardEnterSpiMode();
static UCHAR sendCommand();

/************************************
 * STATIC FUNCTIONS
 ************************************/
//-----------------------------------------------------------------------
static void
startTimer( //Function to start a timer (ms)
		UINT uiTime_) //Desired time to elapse
{
	uiTimeStart = HAL_GetTick();
	uiDelayTime = uiTime_;
}

//-----------------------------------------------------------------------
static BOOLE //Whether desired time has elapsed
timerDone()
{
	return ((HAL_GetTick() - uiTimeStart) >= uiDelayTime);
}

//-----------------------------------------------------------------------
static inline BOOLE // True if successfully selected, false otherwise
spiSelect()
{
	// Assert SPI CS
	ASSERT_SDCARD_CS();


}
//-----------------------------------------------------------------------
static UCHAR // Received byte
spiSendReceiveByte ( // Sending a receiving a byte from the SD Card
		UCHAR data_)
{

}

//-----------------------------------------------------------------------
static void
spiReceiveBytes (
		UCHAR* receive_,
		UINT length_)
{

}

//-----------------------------------------------------------------------
static void
spiSendBytes ( // Wrapper of HAL SPI transmit, sends multiple bytes
		const UCHAR* const data_, // Bytes to send
		UINT length_) // Number of bytes to send
{
	HAL_SPI_Transmit(&hspi2, data_, length_, HAL_MAX_DELAY);

}

//-----------------------------------------------------------------------
static BOOLE // Return whether SPI mode was successfully entered
sdCardEnterSpiMode() // Function to enter SDCard in SPI mode
{
	/* Context: As per "Physical Layer Simplified Specification Ver9.10
	 * The SD Card is powered up in the SD mode. To enter SPI mode assert CS
	 * during the reception of the reset command (CMD0). If SPI mode is required, the card will
	 * switch to SPI and respond with the SPI mode R1 response.
	 */

	// Step 1: Supply at least 80 clock cycles with CS de-asserted
	// to give the card time to start up and clock in SPI
	spiDeselect();
	UCHAR aucDummyBytes[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
	spiSendBytes(aucDummyBytes, sizeof(aucDummyBytes));

	// Step 2: Send CMD0 (reset command)
	if (sendCommand(CMD0) == R1)
	{
		return TRUE;
	}
	return FALSE;
}

/************************************
 * GLOBAL FUNCTIONS
 ************************************/
//-----------------------------------------------------------------------
extern DSTATUS // Status of disk function
sdcard_userInitialize ( //
		BYTE pdrv_) // SDCard number
{
	// Step 1: Configuration + Power Up

	// Give Card Time to Power Up
	StartTimer(2);

	// If drive 0 is not selected return not initialized, currently only one drive is not supported
	if (pdrv_ != 0)
	{
		ucCardStatus |= STA_NOINIT;
		return ucCardStatus;
	}

	// Check if card is present (no current implementation)
	if (SDCardPresent())
	{
		ucCardStatus &= ~STA_NODISK;
	}

	// Check if card is write protected (no current implementation)
	if (SDCardWriteProtected())
	{
		ucCardStatus &= ~STA_PROTECT;
	}

	// At this point card needs to be stable
	while (!TimerDone()) {}

	// Lower SPI Speed (INIT requires 100-400khz)
	SLOW_SPI_CLK();

	// Step 2: If SPI mode is entered successfully, continue INIT process, otherwise return no INIT
	if (!sdCardEnterSpiMode())
	{

	}
	else
	{
		ucCardStatus &= STA_NOINIT;
	}

	return ucCardStatus;

}

inline DSTATUS
sdcard_userStatus (
		BYTE pdrv_)
{

}
inline DRESULT
sdcard_userRead (
		BYTE pdrv_,
		BYTE *buff_,
		DWORD sector_,
		UINT count_)
{

}

#if _USE_WRITE == 1

  inline DRESULT
  sdcard_userWrite (BYTE pdrv_,
		  const BYTE *buff_,
		  DWORD sector_,
		  UINT count_)
  {

  }

#endif /* _USE_WRITE == 1 */

#if _USE_IOCTL == 1

  inline DRESULT
  sdcard_userIoctl (
		  BYTE pdrv_,
		  BYTE cmd_,
		  void *buff_)
  {

  }


#endif /* _USE_IOCTL == 1 */
