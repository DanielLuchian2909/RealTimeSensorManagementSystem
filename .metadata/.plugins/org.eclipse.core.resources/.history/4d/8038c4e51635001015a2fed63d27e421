/**
 ********************************************************************************
 * @file diskio_spi.c
 * @author
 * @brief
 ********************************************************************************
 */

/************************************
 * INCLUDES
 ************************************/
#include "diskio_spi.h"
#include "spi.h"

/************************************
 * EXTERN VARIABLES
 ************************************/
//SDHC card
/************************************
 * PRIVATE MACROS AND DEFINES
 ************************************/
// Command Frame Information
#define CMD_LEN_BYTES 6

// Byte 0 Info
#define CMD_START_BIT_POS 		(7)
#define CMD_START_BIT_MASK		(0x0 << CMD_START_BIT_POS)
#define	CMD_TRANS_BIT_POS       (6)
#define CMD_TRANS_BIT_MASK      (0x1 << CMD_TRANS_BIT_POS)
#define CMD_INDEX_MASK          (0x3F)

// Byte 5 Info
#define CMD_END_BIT_POS 		(0)
#define CMD_END_BIT_MASK		(0x1 << CMD_START_BIT_POS)

// Commands
#define CMD0 		(0x00) //GO_IDLE_STATE
#define CMD0_CRC7   (0x95)
#define CMD8        (0x08)
#define CMD8_CRC7   (0x87)

// Responses
#define R1   		(0x01)

// SPI Specific Macros
#define ASSERT_SDCARD_CS() HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_RESET)
#define DEASSERT_SDCARD_CS() HAL_GPIO_WritePin(SPI2_CS_GPIO_Port, SPI2_CS_Pin, GPIO_PIN_SET)

// Clear BaudRate register (bits [5:3] of CR1)then write 256 as the slow pre-scaler (~200khz) and 4 as the fast (~12mhz)
#define SLOW_SPI_CLK() MODIFY_REG(hspi2.instance->CR1, SPI_CR1_BR, SPI_BAUDRATEPRESCALER_256)
#define FAST_SPI_CLK() MODIFY_REG(hspi2.instance->CR1, SPI_CR1_BR, SPI_BAUDRATEPRESCALER_4)

// SD Card Configuration Macros
#define sdCardPresent() TRUE
#define sdCardWriteProtected() TRUE

/************************************
 * PRIVATE TYPEDEFS
 ************************************/

/************************************
 * STATIC VARIABLES
 ************************************/
// Timing Functionality
static DWORD uiStartTime;
static DWORD uiDelayTime;

// Card Status (By default: no INIT, not present, write protected)
static DSTATUS ucCardStatus = STA_NOINIT | STA_NODISK | STA_PROTECT;

/************************************
 * GLOBAL VARIABLES
 ************************************/

/************************************
 * STATIC FUNCTION PROTOTYPES
 ************************************/
// Timer functionality
static void startTimer(DWORD uiTime_);
static DWORD timerDone();

// SPI Functionality
static BYTE spiSendReceiveByte(BYTE data_);
static void spiReceiveBytes(BYTE *receive_, DWORD length_);
static void spiSendBytes(const BYTE *const data_, DWORD length_);
static inline BOOLE spiSelect();
static inline BOOLE spiDeselect();

// Command TX/RX
static BYTE sendCommand();
static BOOLE sdCardEnterSpiMode();

/************************************
 * STATIC FUNCTIONS
 ************************************/
//-----------------------------------------------------------------------
static void startTimer( //Function to start a timer (ms)
		DWORD uiTime_) //Desired time to elapse
{
	uiTimeStart = HAL_GetTick();
	uiDelayTime = uiTime_;
}

//-----------------------------------------------------------------------
static BOOLE //Whether desired time has elapsed
timerDone() {
	return ((HAL_GetTick() - uiTimeStart) >= uiDelayTime);
}

//-----------------------------------------------------------------------
static inline BOOLE // True if successfully selected, false otherwise
spiSelect() {
	// Assert SPI CS
	ASSERT_SDCARD_CS();

}
//-----------------------------------------------------------------------
static BYTE // Received byte
spiSendReceiveByte( // Sending a receiving a byte from the SD Card
		BYTE data_) {

}

//-----------------------------------------------------------------------
static void spiReceiveBytes(BYTE *receive_, DWORD length_) {

}

//-----------------------------------------------------------------------
static void spiSendBytes( // Wrapper of HAL SPI transmit, sends multiple bytes
		const BYTE *const data_, // Bytes to send
		DWORD length_) // Number of bytes to send
{
	HAL_SPI_Transmit(&hspi2, data_, length_, HAL_MAX_DELAY);

}

//-----------------------------------------------------------------------
static BYTE // Returns response of CMD (always one byte)
sendCommand( // Sends a specified SD Card command
		BYTE cmd_, // CMD to send
		DWORD arg_,) // Arguments of the CMD
{

	/*
	 * SD SPI Command Packet Format (6 bytes)
	 * -------------------------------------------------------------------------
	 * | Bit  | 47   | 46   | 45 ........ 40 | 39 ............ 8  | 7 .. 1 | 0 |
	 * |------|------|------|----------------|--------------------|--------|---|
	 * | Desc | Start| Trans| Cmd Index [5:0]| Argument [31:0]    | CRC7   | 1 |
	 * | Val  |  0   |  1   |       X        |         X          |   X    | 1 |
	 * -------------------------------------------------------------------------
	 */

	BYTE cmdBytes[CMD_LEN_BYTES];

	// Building and sending CMD Bytes
	cmdBytes[0] = CMD_START_BIT_MASK | CMD_TRANS_BIT_MASK | (cmd_ & CMD_INDEX_MASK);
	cmdBytes[1] = (BYTE)(arg_ >> 24);
	cmdBytes[2] = (BYTE)(arg_ >> 16);
	cmdBytes[3] = (BYTE)(arg_ >> 8);
	cmdBytes[4] = (BYTE)(arg_ >> 0);
	cmdBytes[5] =  CMD_END_BIT_MASK;

	// Adjust CRC field based on commands
	if (cmd_ == CMD0)
	{
		cmdBytes[5] = CMD0_CRC7;
	}
	if (cmd_ == CMD8)
	{
		cmdBytes[5] = CMD8_CRC7;
	}

	// Send the bytes
	spiSendBytes(cmdBytes, CMD_LEN_BYTES);

	// Check the response




}

//-----------------------------------------------------------------------
static BOOLE // Return whether SPI mode was successfully entered
sdCardEnterSpiMode() // Function to enter SDCard in SPI mode
{
	/* Context: As per "Physical Layer Simplified Specification Ver9.10
	 * The SD Card is powered up in the SD mode. To enter SPI mode assert CS
	 * during the reception of the reset command (CMD0). If SPI mode is required, the card will
	 * switch to SPI and respond with the SPI mode R1 response.
	 */

	// Step 1: Supply at least 80 clock cycles with CS de-asserted
	// to give the card time to start up and clock in SPI
	spiDeselect();
	BYTE aucDummyBytes[8] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
	spiSendBytes(aucDummyBytes, sizeof(aucDummyBytes));

	// Step 2: Send CMD0 (reset command)
	if (sendCommand(CMD0) == R1) {
		return TRUE;
	}
	return FALSE;
}

/************************************
 * GLOBAL FUNCTIONS
 ************************************/
//-----------------------------------------------------------------------
extern DSTATUS // Status of disk function
sdcard_userInitialize( //
		BYTE pdrv_) // SDCard number
{
	// Step 1: Configuration + Power Up

	// Give Card Time to Power Up
	StartTimer(2);

	// If drive 0 is not selected return not initialized, currently only one drive is not supported
	if (pdrv_ != 0) {
		ucCardStatus |= STA_NOINIT;
		return ucCardStatus;
	}

	// Check if card is present (no current implementation)
	if (SDCardPresent()) {
		ucCardStatus &= ~STA_NODISK;
	}

	// Check if card is write protected (no current implementation)
	if (SDCardWriteProtected()) {
		ucCardStatus &= ~STA_PROTECT;
	}

	// At this point card needs to be stable
	while (!TimerDone()) {
	}

	// Lower SPI Speed (INIT requires 100-400khz)
	SLOW_SPI_CLK();

	// Step 2: If SPI mode is entered successfully, continue INIT process, otherwise return no INIT
	if (!sdCardEnterSpiMode()) {

	} else {
		ucCardStatus &= STA_NOINIT;
	}

	return ucCardStatus;

}

//-----------------------------------------------------------------------
inline DSTATUS
sdcard_userStatus(
		BYTE pdrv_) {

}

//-----------------------------------------------------------------------
inline DRESULT
sdcard_userRead(
		BYTE pdrv_,
		BYTE *buff_,
		DWORD sector_,
		DWORD count_) {

}

#if _USE_WRITE == 1

//-----------------------------------------------------------------------
inline DRESULT
sdcard_userWrite(
		BYTE pdrv_,
		const BYTE *buff_,
		DWORD sector_,
		DWORD count_) {

}

#endif /* _USE_WRITE == 1 */

#if _USE_IOCTL == 1

//-----------------------------------------------------------------------
inline DRESULT
sdcard_userIoctl(
		BYTE pdrv_,
		BYTE cmd_,
		void *buff_) {

}

#endif /* _USE_IOCTL == 1 */
